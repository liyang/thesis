\documentclass[12pt,twoside]{report}

\usepackage{setspace}
\doublespacing
\usepackage[left=1.5in,right=1in,top=1in,bottom=1in]{geometry}

% display date and time of when PDF was made
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhead{}
\fancyfoot[RO,LE]{\scriptsize{\input{now}}}
\renewcommand{\headrulewidth}{0pt}

\input{polycode.lhs}

\usepackage{url}
\usepackage{longtable}
\usepackage{multirow}
\usepackage{comment}

%\def\TODO#1{\par\noindent{}TODO:~\ldots\emph{#1}\ldots\par}
\def\TODO#1{\noindent{}TODO:~\ldots\emph{#1}\ldots}

\def\source#1{}

\usepackage{amsmath}


% lhs2TeX
%{{{%
\usepackage[pdftex]{color}

\renewcommand\hsindent[1]{\quad}
\setlength{\mathindent}{2ex}
\DeclareMathAlphabet{\mathkw}{OT1}{cmss}{bx}{n}

\newcommand\cons[1]{\textcolor[rgb]{0,.5,0}{\mathsf{#1}}}
\newcommand\type[1]{\textcolor[rgb]{0,0,.75}{\mathsf{#1}}}
\newcommand\keyw[1]{\textcolor[rgb]{.75,.4,0}{\mathkw{#1}}}
\newcommand\func[1]{\textcolor[rgb]{.75,0,0}{\mathsf{#1}}}
\newcommand\name[1]{\textcolor[rgb]{.75,0,.75}{\mathtt{#1}}}
\newcommand\commentstyle[1]{\textcolor[rgb]{0,.6,0.75}{#1}}

\newcommand\Prime{\ensuremath{'}}
\newcommand\PPrime{\ensuremath{''}}

\newcommand\prefix[1]{#1\!}
\newcommand\postfix[1]{\!#1}

\newcommand\infix[1]{\mathbin{#1}}
\newcommand\infixL[1]{\infix{#1}\!}
\newcommand\infixM[1]{\!\infix{#1}\!}
\newcommand\infixR[1]{\!\infix{#1}}
%}}}%




\includeonly{semantics,agda.lagda}
\begin{document}

\begin{titlepage}
\begin{center}
\vspace*{1in}
{\LARGE Compiling Concurrency Correctly}
\par
{\Large Verifying Software Transactional Memory}
\par
\vspace{1.5in}
{\large Liyang HU}
\par
\vfill
A Thesis submitted for the degree of Doctor of Philosophy
\par
\vspace{0.5in}
School of Computer Science
\par
\vspace{0.5in}
University of Nottingham
\par
\vspace{0.5in}
June 2010
\end{center}
\end{titlepage}

\pagenumbering{roman}

\begin{abstract}%{{{%
Concurrent programming is notoriously difficult, but with multi-core
processors becoming the norm, it is now a reality that every programmer must
face. Concurrency has traditionally been managed using low-level
mutual exclusion \emph{locks}, which are error-prone and do not naturally
support the compositional style of programming that is becoming
indispensable for today's large-scale software projects.

A novel, high-level approach that has emerged in recent years is that of
\emph{software transactional memory} (STM), which avoids the need for
explicit locking, instead presenting the programmer with a declarative
approach to concurrency. However, its implementation is much more complex
and subtle, and ensuring its correctness places significant demands on the
compiler writer.

This thesis considers the problem of formally verifying a compiler for STM.
Based on a minimal language, we first explore various STM design choices,
along with the issue of compiler correctness via the use of automated
testing tools. Then we outline a new approach to concurrent compiler
correctness using the notion of bisimulation, implemented using the Agda
theorem prover. Finally, we apply this approach to our minimal language to
give the first formally verified compiler for software transactional memory.
\end{abstract}%}}}%

\chapter*{Acknowledgements}
...

\tableofcontents
%\listoffigures

\pagenumbering{arabic}

\include{introduction.lhs}
\include{stm.lhs}
\include{semantics}
\include{testing.lhs}
\include{model.lhs}
\include{agda.lagda}
\include{nondet.lagda}
\include{concurrency.lagda}
\include{verified.lagda}
\include{conclusion}

\bibliographystyle{alpha}
\bibliography{thesis}

\end{document}

