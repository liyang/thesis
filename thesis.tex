\documentclass[12pt,twoside,openright]{book}

\usepackage{setspace}
\doublespacing
\usepackage[left=1.5in,right=1in,top=1in,bottom=1in]{geometry}

% display date and time of when PDF was made
%\input{now}
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhead{}
\fancyhead[LE]{\leftmark}
\fancyhead[RO]{\rightmark}
\fancyfoot{}
\fancyfoot[LE,RO]{\thepage}
%\fancyfoot[RE,LO]{\scriptsize\rightnow}
\renewcommand{\headrulewidth}{0pt}
\headheight 14.5pt


\usepackage{url}
\usepackage{longtable}
\usepackage{multirow}
\usepackage{comment}
\usepackage{marvosym}

\input{polycode.lhs}

%\def\TODO#1{\par\noindent{}TODO:~\ldots\emph{#1}\ldots\par}
\def\TODO#1{\noindent{}TODO:~\ldots\emph{#1}\ldots}

\def\source#1{}

\usepackage{amsmath}
\usepackage{amsthm}
\newtheorem{theorem}{Theorem}[chapter]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}

\def\eqName#1{\textsf{\mdseries(#1)}}
\def\eqTag#1{\tag*{\eqName{#1}}}


\usepackage{mathpartir}
\def\TirName#1{\eqName{#1}}

\usepackage[pdftex,matrix,arrow,curve,color]{xy}
% for arrow labels in xymatrix
\usepackage{rotating}
\def\xyrot#1#2{\begin{turn}{#1}\parbox[c][1.5ex][c]{1.5ex}{\makebox[1.5ex][c]{$#2$}}\end{turn}}
% agda-mode doesn't like {-
\def\xyar{\ar@{->}}
\def\xyarr{\ar@{->>}}

% vector lookup for verified chapter
\def\index[#1]{\!\texttt[#1\texttt]\!}

% lhs2TeX
%{{{%
\usepackage[pdftex]{color}

\renewcommand\hsindent[1]{\quad}
\setlength{\mathindent}{2ex}
\DeclareMathAlphabet{\mathkw}{OT1}{cmss}{bx}{n}

\newcommand\keyw[1]{\textcolor[rgb]{.75,.4,0}{\mathkw{#1}}}
\newcommand\type[1]{\textcolor[rgb]{0,0,.75}{\mathsf{#1}}}
\newxyColor{type}{0 0 0.75}{rgb}{}
% \newcommand\tcls[1]{\textcolor[rgb]{.25,0,.75}{\mathsf{#1}}}
\newcommand\cons[1]{\textcolor[rgb]{0,.5,0}{\mathsf{#1}}}
\newcommand\dstr[1]{\textcolor[rgb]{.75,.75,0}{\mathsf{#1}}}
\newcommand\func[1]{\textcolor[rgb]{.75,0,0}{\mathsf{#1}}}
\newcommand\ltrl[1]{\textcolor[rgb]{.6,0,.6}{\mathtt{#1}}}
\newcommand\name[1]{\textcolor[rgb]{.75,0,.75}{\mathsf{#1}}}
\newcommand\commentstyle[1]{\textcolor[rgb]{0,.6,0.75}{#1}}
\newcommand\shed[1]{\colorbox[rgb]{.6,1,.6}{#1}}

\def\hide#1{}

\newcommand\Prime{\ensuremath{'}}
\newcommand\PPrime{\ensuremath{''}}

\newcommand\prefix[1]{{\!}\mathbin{#1}}
\newcommand\postfix[1]{\mathbin{#1}{\!}}

\newcommand\infix[1]{\mathbin{#1}}
\newcommand\infixL[1]{\infix{#1}\!}
\newcommand\infixM[1]{\!\infix{#1}\!}
\newcommand\infixR[1]{\!\infix{#1}}
%}}}%



% \includeonly{semantics,agda.lagda}
\begin{document}

\pagestyle{empty}
\begin{titlepage}
\begin{center}
\vspace*{1in}
{\LARGE Compiling Concurrency Correctly}
\par
{\Large Verifying Software Transactional Memory}
\par
\vspace{1.5in}
{\large Liyang HU}
\par
\vfill
A Thesis submitted for the degree of Doctor of Philosophy
\par
\vspace{0.5in}
School of Computer Science
\par
\vspace{0.5in}
University of Nottingham
\par
\vspace{0.5in}
October 2010
\end{center}
\cleardoublepage
\end{titlepage}


\pagestyle{fancy}
\pagenumbering{roman}

%{{{%
\begin{center}
{\large\bf Abstract}
\end{center}

Concurrent programming is notoriously difficult, but with multi-core
processors becoming the norm, is now a reality that every programmer must
face. Concurrency has traditionally been managed using low-level mutual
exclusion \emph{locks}, which are error-prone and do not naturally support
the compositional style of programming that is becoming indispensable for
today's large-scale software projects.

A novel, high-level approach that has emerged in recent years is that of
\emph{software transactional memory} (STM), which avoids the need for
explicit locking, instead presenting the programmer with a declarative
approach to concurrency. However, its implementation is much more complex
and subtle, and ensuring its correctness places significant demands on the
compiler writer.

This thesis considers the problem of formally verifying a compiler for STM.
Utilising a minimal language incorporating only the features that we are
interested in studying, we first explore various STM design choices, along
with the issue of compiler correctness via the use of automated testing
tools. Then we outline a new approach to concurrent compiler correctness
using the notion of bisimulation, implemented using the Agda theorem prover.
Finally, we apply this approach to our minimal language to give the first
formally verified compiler for software transactional memory.

%}}}%

\chapter*{Acknowledgements and Thanks}

\ldots

%\begin{itemize}
%\item GMH for his guidance and keeping me on track
%\item CTM for infecting me with DTP
%\item PGH for discussions on transactions
%\item NAD for Agda assistance and stdlib
%\item Ulf for developing Agda
%\item RKSD for figuratively\footnote{xkcd-figuratively} beating me into
%submission
%\item AJ for being my muse and therapist, particularly during the more
%emotionally difficult parts of the write-up
%\item TD's seemingly inexhaustible enthusiasm for inspiring me to get the
%hell on with it
%\item something about my parents (not forcing me to get a real job?)
%\end{itemize}

\tableofcontents
%\listoffigures

{\include{introduction.lhs}}
{\include{stm.lhs}}
{\include{semantics}}
{\include{testing.lhs}}
{\include{model.lhs}}
{\include{agda.lagda}}
{\include{nondet.lagda}}
{\include{fork.lagda}}
{\include{verified.lagda}}
{\include{conclusion}}

\bibliographystyle{alpha}
\bibliography{thesis}

\end{document}

